---
title: "A primer on mechanistic inference with differentiable process-based models in Julia"
jupyter: julia-1.10
execute: 
    eval: true
    cache: true
showsol: true
format:
    html:
        toc: true
        toc-depth: 4
        # toc-expand: 2
    ipynb: default
editor:
  render-on-save: true
---


Here you will learn about different techniques to infer parameters of a (differentiable) process-based model against data. This is useful to in the context of mechanistic inference, where we want to explain patterns in a system by understanding the processes that generate them, in contrast to purely statistical or empirical inference, which might identify patterns or correlations in data without necessarily understanding the causes. We'll mostly focus on differential equation models. Make sure that you stick to the end, where we'll see how we can not only infer parameter values but also functional forms, by parametrizing models' components with neural networks.

# Preliminaries
## Wait, what is a differentiable model?
One can usually write a model as a map $\mathcal{M}$ mapping some parameters $p$, an initial state $u_0$ and a time $t$ to a future state $u_t$

$$u_t = \mathcal{M}(u_0, t, p).$$

We call **differentiable** a model $\mathcal{M}$ for which we can calculate its derivative with respect to $p$ or $u_0$. The derivative $\frac{\partial \mathcal{M}}{\partial \theta}$ expresses how much the model output changes with respect to a small change in $\theta$.

::: {.callout-note}

# Recall your Calculus class!

$$\frac{df}{dx}(x) = \lim_{h \to 0} \frac{f(x + h) - f(x)}{h}$$
:::

Let's illustrate this concept with the [logistic equation model](https://en.wikipedia.org/wiki/Logistic_function#In_ecology:_modeling_population_growth).
This model has an analytic formulation given by:

$$\mathcal{M}(u_0, p, t) = \frac{K}{1 + \big( \frac{K-u_0}{u_0} \big) e^{rt}}$$

Let's code it

```{julia}
using UnPack
using Plots
using Random
using ComponentArrays
using BenchmarkTools
Random.seed!(0)

function mymodel(u0, p, t)
    T = eltype(u0)
    @unpack r, K = p

    @. K / (one(T) + (K - u0) / u0 * exp(-r * t))
end

p = ComponentArray(;r = 1., K = 1.)
u0 = 0.005

tsteps = range(0, 20, length=100)
y = mymodel(u0, p, tsteps)

plot(tsteps, y)
```

::: {.callout-note}

# What is a `ComponentArray`?
A `ComponentArray` is a convenient Array type that allows to access array elements with symbols, similarly to a `NamedTuple`, while behaving like a standard array. For instance, you could do something like

```{julia}
cv = ComponentVector(;a = 1, b = 2)
cv .= [3, 4]
```
This is useful, because you can only calculate a gradient w.r.t a `Vector`!

:::


Now let's try to calculate the gradient of this model. While you could in this case derive the gradient analytically, an analytic derivation is generally tricky with complex models. And what about models that can only be simulated numerically, with no analytic expressions? We need to find a more automatized way to calculate gradients. 

How about [the finite difference method](https://en.wikipedia.org/wiki/Finite_difference_method)?




::: {.callout-tip icon=false}
# Exercise: finite differences

Implement the function `∂mymodel_∂K(h, u0, p, t)` which returns the model's derivative with respect to `K`, calculated with a small `h` to be provided by the user.

::: {.callout-caution icon=false collapse="true"}
# Solution

::: {.content-hidden unless-meta="showsol"}
```{julia}
function ∂mymodel_∂K(h, u0, p, t)
    phat = (; r = p.r, K= p.K + h)
    return (mymodel(u0, phat, t) - mymodel(u0, p, t)) / h
end

∂mymodel_∂K(1e-1, u0, p, 1.)
```
:::

::: {.content-visible unless-meta="showsol"}
```{julia}
#...
```
:::
:::
:::
The gradient of the model is useful to understand how a parameter influences the output of the model. Let's calculate the importance of the carrying capacity `K` on the model output:

```{julia}
dm_dp = ∂mymodel_∂K(1e-1, u0, p, tsteps)
plot(tsteps, dm_dp)
```

As you can observe, the carrying capacity has no effect at small $t$ where population is small, and its influence on the dynamics grows as the population grows. We expect the reverse effect for $r$.

## On the importance of gradients for inference

The ability to calculate the derivative of a model is crucial when it comes to inference. Both within a full Bayesian inference context, where one wants to sample the posterior distribution of parameters $\theta$ given data $u$, $p(\theta| u)$, or when one wants to obtain a point estimate $\theta^\star = \argmax_\theta (p(\theta | u))$ (frequentist or machine learning context), the model gradient proves very useful. In a full Bayesian inference context, they are used e.g. with Hamiltonian Markov Chains methods, such as the NUTS sampler, and in a machine learning context, they are used with gradient-based optimizer.


### Gradient descent
The best way to grasp the importance of gradients in inference is to understand the [gradient descent algorithm](https://en.wikipedia.org/wiki/Gradient_descent).


The following picture illustrates the algorithm in the special case where $p$ is one-dimensional.

![](https://editor.analyticsvidhya.com/uploads/631731_P7z2BKhd0R-9uyn9ThDasA.png)

Given an initial estimate of the parameter value $p_0$, $\frac{d \mathcal{M}}{dp}$ is used to suggest a new, better estimate, following

$$p_{n+1} = p_n - \eta \frac{d \mathcal{M}}{dp}(u_0, t, p) $$

where $\eta$ is the learning rate.

Gradient-based methods are usually very efficient in high-dimensional spaces. 

## Automatic differentiation
Let's go back to our method `∂mymodel_∂p`.
What is the optimal value of `h` to calculate the derivative? This is a tricky question, because a too small `h` can lead to round off errors ([see more explanations here](https://book.sciml.ai/notes/08-Forward-Mode_Automatic_Differentiation_(AD)_via_High_Dimensional_Algebras/)) while `h` too large also leads to a bad approximation of the asymptotic definition.

<!-- Also, can you calculate how many evaluations of the model do you need if your parameter is $d$ dimensionsal?
$\mathcal{O}(2 d)$ -->

Fortunately, a bunch of techniques referred to as [**automatic differentiation**](https://en.wikipedia.org/wiki/Automatic_differentiation) (AD) allows to **exactly** differentiate any piece of numerical functions. In practice, your code must be exclusively written within an AD-backend, such as Torch, JAX or Tensorflow. Those libraries do not know how to differentiate code not written in their own language, such as normal Python code.

Fortunately, Julia is an *AD-pervasive language*! This means that any piece of Julia code is theoretically differentiable with AD.

```{julia}
using ForwardDiff

@btime ForwardDiff.gradient(p -> mymodel(u0, p, 1.), p)
```

This is what makes Julia great for model calibration and inference! Write your model in Julia, and any inference method using AD will be able to work with your model!

To learn more about AD in Julia, check-out this [cool blog-post](https://gdalle.github.io/AutodiffTutorial/) and [this short presentation](https://gdalle.github.io/JuliaCon2024-AutoDiff/#/title-slide).

Now let's get started with inference.

# Mechanistic inference

## The mechanistic model and the data
We'll use a simple dynamical community model, the [Lotka Volterra](https://en.wikipedia.org/wiki/Lotka–Volterra_equations) model, to generate data. We'll then contaminate this data with noise, and try to recover the parameters that have generated the data. The goal of the session will be to estimate those parameters from the data, using a bunch of different techniques. 

So let's first generate the data.

```{julia}
using OrdinaryDiffEq

# Define Lotka-Volterra model.
function lotka_volterra(du, u, p, t)
    # Model parameters.
    @unpack α, β, γ, δ = p
    # Current state.
    x, y = u

    # Evaluate differential equations.
    du[1] = (α - β * y) * x # prey
    du[2] = (δ * x - γ) * y # predator

    return nothing
end

# Define initial-value problem.
u0 = [2.0, 2.0]
p_true = (;α = 1.5, β = 1.0, γ = 3.0, δ = 1.0)
# tspan = (hudson_bay_data[1,:t], hudson_bay_data[end,:t])
tspan = (0., 5.)
tsteps = range(tspan[1], tspan[end], 51)
alg = Tsit5()

prob = ODEProblem(lotka_volterra, u0, tspan, p_true)

saveat = tsteps
sol_true = solve(prob, alg; saveat)
# Plot simulation.
plot(sol_true)
```

This is the true state of the system. Now let's contaminate it with observational noise. 


::: {.callout-tip icon=false}
# Exercise: contaminate data with noise

Create a `data_mat` array, which consists of the ODE solution contaminated with a lognormally-distributed noise with standard deviation `0.3`. 

::: {.callout-note}
Note that we add lognormally-distributed noise instead of normally-distributed because we are observing population abundance, which can only be positive.
:::

::: {.callout-caution icon=false collapse="true"}
# Solution
::: {.content-hidden unless-meta="showsol"}
```{julia}
data_mat = Array(sol_true) .* exp.(0.3 * randn(size(sol_true)))
# Plot simulation and noisy observations.
plot(sol_true; alpha=0.3)
scatter!(sol_true.t, data_mat'; color=[1 2], label="")
```
:::
::: {.content-visible unless-meta="showsol"}
```{julia}
# data_mat = ...
```
:::
:::
:::

Now that we have our data, let's do some inference!

## Mechanistic inference as a supervised learning task
We'll get started with a very crude approach to inference, where we'll treat the calibration of our LV model similarly to a supervised machine learning task. To do so, we'll write a loss function, defining a distance between our model and the data, and we'll try to minimize this loss. The parameter minimizing this loss will be our best model parameter estimate.

```{julia}
function loss(p)
    predicted = solve(prob,
                        alg; 
                        p, 
                        saveat,
                        abstol=1e-6, 
                        reltol = 1e-6)

    l = 0.
    for i in 1:length(predicted)
        if all(predicted[i] .> 0)
            l += sum(abs2, log.(data_mat[:, i]) - log.(predicted[i]))
        end
    end
    return l, predicted
end
```

::: {.callout-note}
Notice that we explicitly check whether predictions are > 0, because the log of negative number is not defined and will throw an error! 
:::

Let's define a helper function, that will plot how good does the model perform across different iterations.

```{julia}
losses = []
callback = function (p, l, pred; doplot=true)
    push!(losses, l)
    if length(losses)%10==0
      println("Current loss after $(length(losses)) iterations: $(losses[end])")
    end
    if doplot
        plt = scatter(sol_true.t, data_mat[1,:]; label = "data x", color = :blue, markerstrokewidth=0)
        scatter!(plt, sol_true.t, Array(pred)[1,:]; label = "prediction x", color = :blue, markershape=:star5, markerstrokewidth=0)
        scatter!(plt, sol_true.t, data_mat[2,:]; label = "data y", color = :red, markerstrokewidth=0)
        scatter!(plt, sol_true.t, Array(pred)[2,:]; label = "prediction y", color = :red, markershape=:star5, markerstrokewidth=0)
        display(plot(plt, yaxis = :log10))
    end
    return false
end

```
And let's define a wrong initial guess for the parameters

```{julia}
pinit = ComponentArray(;α = 1., β = 1.5, γ = 1.0, δ = 0.5)

callback(pinit, loss(pinit)...; doplot = true)
```
Our initial predictions are bad, but you'll likely get even worse predictions in a real-case scenario!

We'll use the library `Optimization`, which is a wrapper library around many optimization libraries in Julia. `Optimization` therefore provides us with many different types of optimizers to find parameters minimizing `loss`. We'll specifically use the infamous [Adam optimizer](https://arxiv.org/abs/1412.6980) (187k citations!!!), widely used in ML.

```{julia}
using Optimization
using OptimizationOptimisers
using SciMLSensitivity

adtype = Optimization.AutoZygote()
optf = Optimization.OptimizationFunction((x, p) -> loss(x), adtype)
optprob = Optimization.OptimizationProblem(optf, pinit)

@time res_ada = Optimization.solve(optprob, ADAGrad(0.1); callback = callback, maxiters = 500)
res_ada.minimizer
```

Nice! It seems that the optimizer did a reasonable job, and that we found a reasonable estimate of our parameters!

::: {.callout-tip icon=false}
# Exercise: Hey, this is cheating!

Notice that we use the true `u0`, as if we were to know exactly the initial state. In a real situation, we need also to infer the true state!

Can you modify the model to infer the true state?

::: {.callout-caution icon=false collapse="true"}
# Solution
::: {.content-hidden unless-meta="showsol"}
```{julia}
function loss2(p)
    predicted = solve(prob,
                        alg; 
                        p,
                        u0 = p.u0,
                        saveat,
                        abstol=1e-6, 
                        reltol = 1e-6)

    l = 0.
    for i in 1:length(predicted)
        if all(predicted[i] .> 0)
            l += sum(abs2, log.(data_mat[:, i]) - log.(predicted[i]))
        end
    end
    return l, predicted
end
losses = []

pinit = ComponentArray(;α = 1., β = 1.5, γ = 1.0, δ = 0.5, u0 = data_mat[:,1])

adtype = Optimization.AutoZygote()
optf = Optimization.OptimizationFunction((x, p) -> loss2(x), adtype)
optprob = Optimization.OptimizationProblem(optf, pinit)

@time res_ada = Optimization.solve(optprob, ADAGrad(0.1); callback = callback, maxiters = 1000)
res_ada.minimizer
```
:::
::: {.content-visible unless-meta="showsol"}
```{julia}
# function loss2(p)
#    ...
# end
# losses = []

# pinit = ...

# adtype = Optimization.AutoZygote()
# optf = Optimization.OptimizationFunction((x, p) -> loss2(x), adtype)
# optprob = Optimization.OptimizationProblem(optf, pinit)

# @time res_ada = Optimization.solve(optprob, ADAGrad(0.1); callback = callback, maxiters = 1000)
# res_ada.minimizer
```
:::
:::
:::

## Regularization
In supervised learning, it is common practice to regularize the model to prevent overfitting. Regularization can also help the model to converge. Regularization is done by adding a penalty term to the loss function:

$$
\text{Loss}(\theta) = \text{Loss}_{\text{data}}(\theta) + \lambda \, \text{Reg}(\theta)
$$

::: {.callout-tip icon=false}
# Exercise: regularization
Add a regularization term to the loss, which penalizes the loss when the inferred initial conditions are less than 0.

::: {.content-visible unless-meta="showsol"}
::: {.callout-caution icon=false}
# Solution
```{julia}
#...
```
:::
:::
:::

## Multiple shooting
Another trick that can greatly improve the convergence of the optimization is to break down the prediction task into simpler tasks. Namely, instead of trying to predict in one shot the whole time series, the idea of multiple shooting is to predict for shorter time horizon.

::: {.callout-tip icon=false}
# Exercise: multiple shooting
Can you modify your loss function to implement this idea?

::: {.content-hidden unless-meta="showsol"}
::: {.callout-caution icon=false collapse="true"}
# Solution
```{julia}
function multiple_shooting_idx(N, length_interval = 10)
    K = N ÷ length_interval
    @assert N % K == 1 "`N - 1` is not a multiple of `length_interval`"
    interval_idxs = [k*length_interval+1:(k+1)*length_interval+1 for k in 0:(K-1)]
    return interval_idxs
end

function loss_multiple_shooting(p)
    interval_idxs = multiple_shooting_idx(length(tsteps))
    l = 0.
    for idx in interval_idxs
        saveat = tsteps[idx]
        # u0_i = sol_true.u[idx[1]] # here we are cheating, using true states for initial conditions!
        u0_i = data_mat[:, idx[1]] # this is not cheating, but it does not work very well
        predicted = solve(prob,
                        alg; 
                        u0 = u0_i,
                        p, 
                        saveat,
                        tspan=(saveat[1], saveat[end]),
                        abstol=1e-6, 
                        reltol = 1e-6)
        for i in 1:length(predicted)
            if all(predicted[i] .> 0)
                l += sum(abs2, log.(data_mat[:, idx[i]]) - log.(predicted[i]))
            end
        end

    end

    predicted = solve(prob,
                    alg; 
                    p,
                    saveat=tsteps,
                    abstol=1e-6, 
                    reltol = 1e-6)
    return l, predicted
end
losses = []

pinit = ComponentArray(;α = 1., β = 1.5, γ = 1.0, δ = 0.5)

adtype = Optimization.AutoZygote()
optf = Optimization.OptimizationFunction((x, p) -> loss_multiple_shooting(x), adtype)
optprob = Optimization.OptimizationProblem(optf, pinit)

@time res_ada = Optimization.solve(optprob, ADAGrad(0.1); callback = callback, maxiters = 500)
res_ada.minimizer
```
:::
:::
::: {.content-visible unless-meta="showsol"}
::: {.callout-caution icon=false}
# Solution
```{julia}
# tsteps = sol_true.t

# function loss_multiple_shooting(p)
#     length_interval = 20
#     K = length(tsteps) ÷ length_interval
#     @assert length(tsteps) % K == 1 "`length(tsteps) - 1` is not a multiple of `length_interval`"
#     interval_idxs = [k*length_interval+1:(k+1)*length_interval+1 for k in 0:(K-1)]

#     l = 0.
#     for idx in interval_idxs
#         ...
#     end

#     predicted = solve(prob,
#                     alg; 
#                     p,
#                     saveat=tsteps,
#                     abstol=1e-6, 
#                     reltol = 1e-6)
#     return l, predicted
# end
# losses = []

# pinit = ComponentArray(;α = 1., β = 1.5, γ = 1.0, δ = 0.5)

# adtype = Optimization.AutoZygote()
# optf = Optimization.OptimizationFunction((x, p) -> loss(x), adtype)
# optprob = Optimization.OptimizationProblem(optf, pinit)

# @time res_ada = Optimization.solve(optprob, ADAGrad(0.1); callback = callback, maxiters = 500)
# res_ada.minimizer
```
:::
:::
:::

## Sensitivity methods
Did you wonder why do we need to load `SciMLSensitivity`? and why did we specify `adtype = Optimization.AutoZygote()`? 

AD comes in different flavours, with broadly two types of AD methods - **forward methods** and **backward methods** -, and a bunch of different implementations. 

You can specify which ones `Optimization.jl` will use to differentiate `loss` with `adtype`, see available options [here](https://docs.sciml.ai/Optimization/stable/API/ad/). 

But when it comes to differentiating the `solve` function from `OrdinaryDiffEq`, you want to use `AutoZygote()`, because when trying to differentiate `solve`, a specific adjoint rule provided by the `SciMLSensitivity` package will be used. 

::: {.callout-note}
# What are adjoint rules?
These are algoirithmic rules that specify to the AD backend *how* to calculate the derivative of a specific function.

If you want to know more, check-out the [ChainRules.jl documentation](https://juliadiff.org/ChainRulesCore.jl/)
:::

These adjoint rules can be specificed by the keyword `sensealg` when calling `solve` and have been designed for best performance when differentiating solutions of an `ODEProblem`. There exists a lot of them (see a review [here](https://arxiv.org/abs/2406.09699)), and if `sensealg` is not provided, a smart polyalgorithm is going to pick up one for you.

You can have a look in the documentation [here](https://docs.sciml.ai/SciMLSensitivity/stable/manual/differential_equation_sensitivities/) for hints on how to choose an algorithm. 


::: {.callout-tip icon=false}
# Exercise: benchmarking sensitivity methods
Can you evaluate the performance of `ForwardDiffSensitivity()` and `ReverseDiffAdjoint()`?

::: {.content-hidden unless-meta="showsol"}
::: {.callout-caution icon=false collapse="true"}
# Solution
```{julia}
using Zygote
function loss_sensealg(p, sensealg)
    predicted = solve(prob,
                        alg; 
                        sensealg,
                        p,
                        u0 = p.u0,
                        saveat,
                        abstol=1e-6, 
                        reltol = 1e-6)

    l = 0.
    for i in 1:length(predicted)
        if all(predicted[i] .> 0)
            l += sum(abs2, log.(data_mat[:, i]) - log.(predicted[i]))
        end
    end
    return l
end
```
```{julia}
pinit = ComponentArray(;α = 1., β = 1.5, γ = 1.0, δ = 0.5, u0 = data_mat[:,1])

@btime Zygote.gradient(p -> loss_sensealg(p, ForwardDiffSensitivity()), pinit)
```

```{julia}
@btime Zygote.gradient(p -> loss_sensealg(p, ReverseDiffAdjoint()), pinit)
```

:::
:::
::: {.content-visible unless-meta="showsol"}
::: {.callout-caution icon=false}
# Solution
```{julia}
#...
```
:::
:::
:::

For a small number of parameters, forward methods tend to perform best, but with higher number of parameters, the other way around is true.

Well done! Now, let's jump into the Bayesian world...

## Bayesian inference

Julia has a very strong library for Bayesian inference: [Turing.jl](https://turinglang.org).

Let's declare our first Turing model!

This is done with the `@model` macro, which allows the library to automatically construct the posterior distribution based on the definition of your model's random variables. 

::: {.callout-note}
# Frequentist (supervised learning) vs. Bayesian approach

The main difference between a frequentist approach and a Bayesian approach is that the latter considers that parameters are random variables. Hence instead of trying to estimate a single value for the parameters, the Bayesian will try to estimate the posterior (joint) distribution of those parameters. 

$$
P(\theta | \mathcal{D}) = \frac{P(\mathcal{D} | \theta) P(\theta)}{P(\mathcal{D})}
$$

:::

Random variables are defined with the `~` symbol.

### Our first Turing model

```{julia}
using Turing
using LinearAlgebra

@model function fitlv(data, prob)
    # Prior distributions.
    σ ~ InverseGamma(3, 0.5)
    α ~ truncated(Normal(1.5, 0.5); lower=0.5, upper=2.5)
    β ~ truncated(Normal(1.2, 0.5); lower=0, upper=2)
    γ ~ truncated(Normal(3.0, 0.5); lower=1, upper=4)
    δ ~ truncated(Normal(1.0, 0.5); lower=0, upper=2)

    # Simulate Lotka-Volterra model. 
    p = (;α, β, γ, δ)
    predicted = solve(prob, alg; p, saveat)

    # Observations.
    for i in 1:length(predicted)
        if all(predicted[i] .> 0)
            data[:, i] ~ MvLogNormal(log.(predicted[i]), σ^2 * I)
        end
    end

    return nothing
end
```

Now we can instantiate our model, and run the inference!

```{julia}

model = fitlv(data_mat, prob)

# Sample 3 independent chains with forward-mode automatic differentiation (the default).
chain = sample(model, NUTS(), MCMCThreads(), 1000, 3; progress=true)

```
::: {.callout-note}
# Threads

How many threads do you have running? `Threads.nthreads()` will tell you!
:::


Let's see if our chains have converged.

```{julia}
using StatsPlots
plot(chain)
```

### Data retrodiction

Let's now generate simulated data using samples from the posterior distribution, and compare to the original data.

```{julia}
function plot_predictions(chain, sol, data_mat)
    myplot = plot(; legend=false)
    posterior_samples = sample(chain[[:α, :β, :γ, :δ]], 300; replace=false)
    for parr in eachrow(Array(posterior_samples))
        p = NamedTuple([:α, :β, :γ, :δ] .=> parr)
        sol_p = solve(prob, Tsit5(); p, saveat)
        plot!(sol_p; alpha=0.1, color="#BBBBBB")
    end

    # Plot simulation and noisy observations.
    plot!(sol; color=[1 2], linewidth=1)
    scatter!(sol.t, data_mat'; color=[1 2])
    return myplot
end
plot_predictions(chain, sol_true, data_mat)
```

::: {.callout-tip icon=false}
# Exercise: Hey, this is cheating!

Notice that we use the true `u0`, as if we were to know exactly the initial state. In a real situation, we need also to infer the true state!

Can you modify the model to infer the true state?

::: {.content-hidden unless-meta="showsol"}
::: {.callout-caution icon=false collapse="true"}
# Solution
```{julia}
@model function fitlv2(data, prob)
    # Prior distributions.
    σ ~ InverseGamma(2, 3)
    α ~ truncated(Normal(1.5, 0.5); lower=0.5, upper=2.5)
    β ~ truncated(Normal(1.2, 0.5); lower=0, upper=2)
    γ ~ truncated(Normal(3.0, 0.5); lower=1, upper=4)
    δ ~ truncated(Normal(1.0, 0.5); lower=0, upper=2)
    u0 ~ MvLogNormal(data[:,1], σ^2 * I)

    # Simulate Lotka-Volterra model but save only the second state of the system (predators).
    p = (;α, β, γ, δ)
    predicted = solve(prob, alg; p, u0, saveat)

    # Observations.
    for i in 2:length(predicted)
        if all(predicted[i] .> 0)
            data[:, i] ~ MvLogNormal(log.(predicted[i]), σ^2 * I)
        end
    end

    return nothing

end

model2 = fitlv2(data_mat, prob)

# Sample 3 independent chains.
chain2 = sample(model2, NUTS(), MCMCThreads(), 3000, 3; progress=true)
plot(chain2)
```
:::
:::
::: {.content-visible unless-meta="showsol"}

::: {.callout-caution icon=false}
# Solution
```{julia}
# @model function fitlv2(data, prob)
#     # Prior distributions.
#     σ ~ InverseGamma(2, 3)
#     α ~ truncated(Normal(1.5, 0.5); lower=0.5, upper=2.5)
#     β ~ truncated(Normal(1.2, 0.5); lower=0, upper=2)
#     γ ~ truncated(Normal(3.0, 0.5); lower=1, upper=4)
#     δ ~ truncated(Normal(1.0, 0.5); lower=0, upper=2)
#     u0 ~ ...
#     ...
# end
# ...
# chain2 = ...
```
:::
:::
:::

Here is a small utility function to visualize your results.

```{julia}
#| code-fold: true
#| code-summary: "`plot_predictions2`"

function plot_predictions2(chain, sol, data_mat)
    myplot = plot(; legend=false)
    posterior_samples = sample(chain, 300; replace=false)
    for i in 1:length(posterior_samples)
        ps = posterior_samples[i]
        p = get(ps, [:α, :β, :γ, :δ], flatten=true)
        u0 = get(ps, :u0, flatten = true)
        u0 = [u0[1][1], u0[2][1]]

        sol_p = solve(prob, Tsit5(); u0, p, saveat)
        plot!(sol_p; alpha=0.1, color="#BBBBBB")
    end

    # Plot simulation and noisy observations.
    plot!(sol; color=[1 2], linewidth=1)
    scatter!(sol.t, data_mat'; color=[1 2])
    return myplot
end

plot_predictions2(chain2, sol_true, data_mat)
```


### Mode estimation
Turing allows you to find the maximum likelihood estimate (MLE) or maximum a posteriori estimate (MAP). 

$$
\theta_{MLE} = \underset{\theta}{\text{argmax}} \, P(\mathcal{D} | \theta), \qquad \theta_{MAP} = \underset{\theta}{\text{argmax}} \, P(\theta | \mathcal{D}).
$$

::: {.callout-note}
# MAP and regularization in supervised learning

Although Bayesian inference seems very different from the supervised learning approach we developed in the first part, estimating the MAP, which can be still considered as Bayesian inference, transforms in an optimization problem that can be seen as a supervised task. 

To see that, we can log-transform the posterior:

$$
\log P(\theta | \mathcal{D}) = \log P(\mathcal{D} | \theta) + \log P(\theta) - \log P(\mathcal{D})
$$

Since the evidence $P(\mathcal{D})$ is independent of $\theta$, it can be ignored when maximizing with respect to $\theta$. Therefore, the MAP estimate simplifies to:

$$
\theta_{MAP} = \underset{\theta}{\text{argmax}} \, \left[\log P(\mathcal{D} | \theta) + \log P(\theta)\right]
$$

Here, $\log P(\mathcal{D}| \theta)$ can be seen as our previous non-regularized `loss` and $\log P(\theta)$ acts as a regularization term, penalizing unlikely parameter values based on our prior beliefs. Priors on parameters can be seen as regularization term.
:::

MLE and MAP can be obtained by `maximum_likelihood` and `maximum_a_posteriori`.

```{julia}
Random.seed!(0)
maximum_a_posteriori(model2, maxiters = 1000)
```
Since `Turing` uses under the hood the same Optimization.jl library, you can specify which optimizer youd'd like to use.

```{julia}
map_res = maximum_a_posteriori(model2, Adam(0.01), maxiters=2000)
```
We can check whether the optimization has converged:

```{julia}
@show map_res.optim_result
```
What's very nice is that Turing.jl provides you with utility functions to analyse your mode estimation results.

```{julia}
using StatsBase
coeftable(map_res)
```

::: {.callout-tip icon=false}
# Exercise: Partially observed state
Let's assume the following situation: for some reason, you only have observation data for the predator. Could you still infer all parameters of your model, including those of the prey?

Could be! Because the signal of the variation in abundance of the predator contains information on the dynamics of the whole predator-prey system.

Do it!

You'll need to assume so prior state for the prey. Just assume that it is the same as that of the predator.

::: {.content-hidden unless-meta="showsol"}
::: {.callout-caution icon=false collapse="true"}
# Solution
```{julia}
@model function fitlv3(data::AbstractVector, prob)
    # Prior distributions.
    σ ~ InverseGamma(2, 3)
    α ~ truncated(Normal(1.5, 0.5); lower=0.5, upper=2.5)
    β ~ truncated(Normal(1.2, 0.5); lower=0, upper=2)
    γ ~ truncated(Normal(3.0, 0.5); lower=1, upper=4)
    δ ~ truncated(Normal(1.0, 0.5); lower=0, upper=2)
    u0 ~ MvLogNormal([data[1], data[1]], σ^2 * I)

    # Simulate Lotka-Volterra model but save only the second state of the system (predators).
    p = (;α, β, γ, δ)
    predicted = solve(prob, Tsit5(); p, u0, saveat, save_idxs=2)

    # Observations of the predators.
    for i in 2:length(predicted)
        if predicted[i] > 0
            data[i] ~ LogNormal(log.(predicted[i]), σ^2)
        end
    end

    return nothing
end

model3 = fitlv3(data_mat[2, :], prob)

# Sample 3 independent chains.
chain3 = sample(model3, NUTS(), MCMCThreads(), 3000, 3; progress=true)
plot(chain3)
p = plot_predictions2(chain3, sol_true, data_mat)
plot!(p, yaxis=:log10)
```
:::
:::
::: {.content-visible unless-meta="showsol"}
::: {.callout-caution icon=false}
# Solution
```{julia}
# @model function fitlv3(data::AbstractVector, prob)
#     # Prior distributions.
#     σ ~ InverseGamma(2, 3)
#     α ~ truncated(Normal(1.5, 0.5); lower=0.5, upper=2.5)
#     β ~ truncated(Normal(1.2, 0.5); lower=0, upper=2)
#     γ ~ truncated(Normal(3.0, 0.5); lower=1, upper=4)
#     δ ~ truncated(Normal(1.0, 0.5); lower=0, upper=2)
#     u0 ~ #...MvLogNormal([data[1], data[1]], σ^2 * I)
#     ...
# end

# model3 = fitlv3(...

# Sample 3 independent chains.
# chain3 = ...
```
:::
:::
:::
<!-- 
How cool!

Now you need to realise that up to now, we had a relatively simple model. How would this model scale, should we have a much larger model? Let's cook-up some idealised LV model. -->


### AD backends and `sensealg`
The `NUTS` sampler uses automatic differentiation under the hood. 

By default, `Turing.jl` uses `ForwardDiff.jl` as an AD backend, meaning that the SciML sensitivity methods are not used when the `solve` function is called. However, you could change the AD backend to `Zygote` with `adtype=AutoZygote()`.

```{julia}
chain2 = sample(model2, NUTS(), MCMCThreads(), adtype=AutoZygote(), 3000, 3; progress=true)
```
Doing so, you could specify within `solve` the `adtype`. It is usually a good idea to try a few different sensitivity algorithm.

See [here](https://turinglang.org/docs/tutorials/docs-10-using-turing-autodiff/index.html) for more information. 

::: {.callout-tip icon=false}
# Exercise: benchmark 

Can you evaluate the performance of `ForwardDiffSensitivity()` and `ReverseDiffAdjoint()`?

::: {.callout-caution icon=false}
# Solution
```{julia}
#...
```
:::
:::

### Variational Inference
Variational inference (VI) consists in approximating the true posterior distribution $P(\theta | \mathcal{D})$ by an approximate distribution $Q(\theta; \phi)$, where $\phi$ is a parameter vector defining the shape, location, and other characteristics of the approximate distribution $Q$, to be optimzed so that $Q$ is as close as possible to $P$. This is achieved by minimizing the Kullback-Leibler (KL) divergence between the true posterior $P(\theta | \mathcal{D})$ and the approximate distribution :

$$
\phi^* = \underset{\phi}{\text{argmin}} \, \text{KL}\left(Q(\theta; \phi) \,||\, P(\theta | \mathcal{D})\right)
$$

The advantage of VI over traditional MCMC sampling methods is that VI is generally faster and more scalable to large datasets, as it transforms the inference problem into an optimization problem.

Let's do VI in Turing!

```{julia}
import Flux
using Turing: Variational
model = fitlv2(data_mat, prob)
q0 = Variational.meanfield(model)
advi = ADVI(10, 10_000) # first arg is the 

q = vi(model, advi, q0; optimizer=Flux.ADAM(1e-2))

function plot_predictions_vi(q, sol, data_mat)
    myplot = plot(; legend=false)
    z = rand(q, 300)
    for parr in eachcol(z)
        p = NamedTuple([:α, :β, :γ, :δ] .=> parr[2:5])
        u0 = parr[6:7]
        sol_p = solve(prob, Tsit5(); u0, p, saveat)
        plot!(sol_p; alpha=0.1, color="#BBBBBB")
    end

    # Plot simulation and noisy observations.
    plot!(sol; color=[1 2], linewidth=1)
    scatter!(sol.t, data_mat'; color=[1 2])
    return myplot
end

plot_predictions_vi(q, sol, data_mat)
```

The cool thing with VI that we can sample from the resulting `q` with ease. 

```{julia}
q isa MultivariateDistribution
```
```{julia}
rand(q)
```


- [Learn more on VI in turing here](https://turinglang.org/docs/tutorials/09-variational-inference/)
- [VI in general here](https://mpatacchiola.github.io/blog/2021/01/25/intro-variational-inference.html)

# Infering functional forms

Up to now, we have been infering the value of the model's parameters, assuming that the structure of our model is correct. But this is very idealistic, specifically in ecology. As a general trend, we have little idea of how does e.g. [the functional response of a species](https://en.wikipedia.org/wiki/Functional_response) look like.

What if instead of inferring parameter values, we could infer functional forms, or components within our model for which we have little idea on how to express it mathematically?

In Julia, we can do that.

To illustrate this, we'll assume that we do not know the functional response of both prey and predator, i.e. the terms `β * y` and `δ * x`. Instead, we will parametrize this component in our DE model by a neural network, which can be seen as a simple non-linear regressor dependent on some extra parameters `p_nn`. 

We then simply have to optimize those parameters, along with the other model's parameters!

Let's get started. To make the neural network, we'll use the deep learning library `Lux.jl`, which is similar to `Flux.jl` but where models are explicitly parametrized. This explicit parametrization makes it simpler to integrate with an ODE model.

To make things simpler, we will define a single layer neural network
```{julia}
using Lux
rng = Random.default_rng()
nn_init = Lux.Chain(Lux.Dense(2,2, relu))
p_nn_init, st_nn = Lux.setup(rng, nn_init)

nn = StatefulLuxLayer(nn_init, st_nn)
```

We use a `StatefulLuxLayer` to not having to carry around `st_nn`, a struct containing states of a Lux model, which is essentially useless for a multi-layer perceptron.

```{julia}
st_nn
```

We can now evaluate our neural network model as follows:

```{julia}
nn(u0, p_nn_init)
```

instead of 
```{julia}
nn_init(u0, p_nn_init, st_nn)
```

Let's define a new parameter vectors, which will consist of the ODE model parameters as well as the neural net parameters

```{julia}
pinit = ComponentArray(;σ = 0.3, α = 1.5, γ = 3.0, p_nn=p_nn_init)
```

::: {.callout-tip icon=false}
# Exercise: neural network-based Lotka-Volterra model
Define the neural network-based Lotka-Volterra model

::: {.content-hidden unless-meta="showsol"}
::: {.callout-caution icon=false collapse="true"}
# Solution
```{julia}
function lotka_volterra_nn(du, u, p, t)
    # Model parameters.
    @unpack α, γ, p_nn = p

    # Current state.
    x, y = u

    û = nn(u, p_nn) # Network prediction


    # Evaluate differential equations.
    du[1] = (α - û[1]) * x # prey
    du[2] = (û[2] - γ) * y # predator

    return nothing
end
```
:::
:::
::: {.content-visible unless-meta="showsol"}
::: {.callout-caution icon=false}
# Solution
```{julia}
# function lotka_volterra_nn(du, u, p, t)
#     # Model parameters.
#     @unpack α, γ, p_nn = ...
#     ...
# end
```
:::
:::
:::

Let's check our initial model predictions:

```{julia}
prob_nn = ODEProblem(lotka_volterra_nn, u0, tspan, pinit)
init_sol = solve(prob_nn, alg; saveat)
# Plot simulation.
plot(init_sol)
```

Now we can define our Turing Model. We'll need to use a utility function `vector_to_parameters` that reconstructs the neural network parameter type based on a sampled parameter vector (taken from [this Turing tutorial](https://quarto.org/docs/output-formats/html-code.html)). You do not need to worry about this. Note that we could have used a component vector, but for some reason this did not work at the time of the writing of this tutorial...

```{julia}
#| code-fold: true
#| code-summary: "`vector_to_parameters`"

using Functors # for the `fmap`
function vector_to_parameters(ps_new::AbstractVector, ps::NamedTuple)
    @assert length(ps_new) == Lux.parameterlength(ps)
    i = 1
    function get_ps(x)
        z = reshape(view(ps_new, i:(i + length(x) - 1)), size(x))
        i += length(x)
        return z
    end
    return fmap(get_ps, ps)
end
```

```{julia}
# Create a regularization term and a Gaussian prior variance term.
sigma = 0.2

@model function fitlv_nn(data, prob)
    # Prior distributions.
    σ ~ InverseGamma(3, 0.5)
    α ~ truncated(Normal(1.5, 0.5); lower=0.5, upper=2.5)
    γ ~ truncated(Normal(3.0, 0.5); lower=1, upper=4)

    nparameters = Lux.parameterlength(nn)
    p_nn_vec ~ MvNormal(zeros(nparameters), sigma^2 * I)

    p_nn = vector_to_parameters(p_nn_vec, p_nn_init)

    # Simulate Lotka-Volterra model. 
    p = (;α, γ, p_nn)

    predicted = solve(prob, alg; p, saveat)

    # Observations.
    for i in 1:length(predicted)
        if all(predicted[i] .> 0)
            data[:, i] ~ MvLogNormal(log.(predicted[i]), σ^2 * I)
        end
    end

    return nothing
end


model = fitlv_nn(data_mat, prob_nn)
```

```{julia}
using Optimization, OptimizationOptimisers
@time mle_res = maximum_likelihood(model, ADAM(0.1), maxiters=1000, initial_params=pinit)
pmle = ComponentArray(;σ=0, pinit...)
pmle .= mle_res.values[:]
sol_mle = solve(prob_nn, alg;p=pmle, saveat, tspan = (0, 10))
plot(sol_mle)
scatter!(sol_true,  color = [:blue :red])
```
This seems to fail.

::: {.callout-tip icon=false}
# Exercise: take some initiative!
What could you do to improve the convergence of the optimization?

::: {.content-hidden unless-meta="showsol"}
::: {.callout-caution icon=false collapse="true"}
# Solution
```{julia}
sigma = 0.2

@model function fitlv_nn(data, prob)
    # Prior distributions.
    σ ~ InverseGamma(3, 0.5)
    α ~ truncated(Normal(1.5, 0.5); lower=0.5, upper=2.5)
    γ ~ truncated(Normal(3.0, 0.5); lower=1, upper=4)

    nparameters = Lux.parameterlength(nn)
    p_nn_vec ~ MvNormal(zeros(nparameters), sigma^2 * I)

    p_nn = vector_to_parameters(p_nn_vec, p_nn_init)


    # Simulate Lotka-Volterra model. 
    p = (;α, γ, p_nn)

    interval_idxs = multiple_shooting_idx(length(tsteps))
    for ts_idx in interval_idxs
        saveat = tsteps[ts_idx]
        u0 = sol_true.u[ts_idx[1]]
        predicted = solve(prob_nn,
                            alg; 
                            tspan = (saveat[1], saveat[end]),
                            u0,
                            p, 
                            saveat,
                            abstol=1e-6, 
                            reltol = 1e-6)


        # Observations.
        for i in 1:length(predicted)
            if all(predicted[i] .> 0)
                data[:, ts_idx[i]] ~ MvLogNormal(log.(predicted[i]), σ^2 * I)
            end
        end
    end

    return nothing
end


model = fitlv_nn(data_mat, prob_nn)

@time mle_res = maximum_likelihood(model, ADAM(0.1), maxiters=1000, initial_params=pinit)
pmle = ComponentArray(;σ=0, pinit...)
pmle .= mle_res.values[:]
sol_mle = solve(prob_nn, alg;p=pmle, saveat, tspan = (0, 10))
plot(sol_mle)
scatter!(sol_true,  color = [:blue :red])
```
:::
:::
::: {.content-visible unless-meta="showsol"}
::: {.callout-caution icon=false}
# Solution
```{julia}
#...
```
:::
:::
:::

Happy with the convergence? Now let's investigate what did the neural network learn!

```{julia}
#| code-fold: true
#| code-summary: "`plot_func_resp`"

function plot_func_resp(pmle, data)
    # plotting prediction of functional response
    u1 = range(minimum(data[1,:]), maximum(data[1,:]), length=100) 
    u2 = range(minimum(data[2,:]), maximum(data[2,:]), length=100) 
    u = hcat(u1,u2)

    func_resp = nn(u', pmle.p_nn)

    myplot1 = plot(u2,
                    p_true.β .* u2; 
                    label="True functional form")
    plot!(myplot1,
                u2,
                func_resp[1,:]; 
                color="#BBBBBB",
                label="Inferred functional form")

    myplot2 = plot(u1,
                    p_true.δ .* u2; 
                    legend=false)

    plot!(myplot2,
            u1,
            func_resp[2,:]; 
            color="#BBBBBB")

    myplot = plot(myplot1, myplot2)
    return myplot
end
```
```{julia}
plot_func_resp(pmle, data_mat)
```

The neural network has well captured the functional forms of the predator and prey.


::: {.callout-tip icon=false}
# Exercise: Probabilistic functional forms
Could you try to obtain a bayesian estimate of the functional forms with e.g. VI?

::: {.callout-caution icon=false}
# Solution
```{julia}
#...
```
:::
:::

This concludes this tutorial; I hope that it has given you plenty of ideas for your future research projects!

## Resources
- https://turinglang.org/docs/tutorials/10-bayesian-differential-equations/
- https://turinglang.org/docs/tutorials/09-variational-inference/
